{
  "name": "jasmine-jquery",
  "version": "1.5.8",
  "main": "lib/jasmine-jquery.js",
  "ignore": [
    "test",
    "vendor",
    ".*",
    "HISTORY.md",
    "SpecRunner.html"
  ],
  "gitHead": "7f01294ee0d5e8a58f20e66df3928ab1478584dc",
  "readme": "# jasmine-jquery\r\n\r\njasmine-jquery provides two extensions for [Jasmine](http://pivotal.github.com/jasmine/) JavaScript Testing Framework:\r\n  \r\n- a set of custom matchers for jQuery framework\r\n- an API for handling HTML, CSS, and JSON fixtures in your specs\r\n\r\n## Installation\r\n\r\nSimply download _jasmine-jquery.js_ from [here](https://raw.github.com/velesin/jasmine-jquery/master/lib/jasmine-jquery.js) and include it in your Jasmine's test runner file (or add it to _jasmine.yml_ file if you're using Ruby with [jasmine-gem](http://github.com/pivotal/jasmine-gem)). Remember to include also jQuery library as jasmine-jquery relies on it.\r\n\r\nFor Ruby on Rails I recommend to comply with the standard RSpec and Jasmine frameworks dir structure and keep your tests in `spec/javascripts/` dir. I put jasmine-jquery (and other libraries like jasmine-ajax) into `spec/javascripts/helpers` dir (so they are automatically loaded) and fixtures into `spec/javascripts/fixtures` dir.\r\n\r\n## jQuery matchers\r\n\r\njasmine-jquery provides following custom matchers (in alphabetical order):\r\n\r\n- `toBe(jQuerySelector)`\r\n  - e.g. `expect($('<div id=\"some-id\"></div>')).toBe('div')`\r\n  - e.g. `expect($('<div id=\"some-id\"></div>')).toBe('div#some-id')`\r\n- `toBeChecked()`\r\n  - only for tags that have checked attribute\r\n  - e.g. `expect($('<input type=\"checkbox\" checked=\"checked\"/>')).toBeChecked()` \r\n- `toBeEmpty()`\r\n  - Checks for child DOM elements or text.\r\n- `toBeHidden()`\r\n  \r\n  Elements can be considered hidden for several reasons:\r\n    - They have a CSS `display` value of `none`.\r\n    - They are form elements with `type` equal to `hidden`.\r\n    - Their `width` and `height` are explicitly set to `0`.\r\n    - An ancestor element is hidden, so the element is not shown on the page.\r\n- `toHaveCss(css)`\r\n  - e.g. `expect($('<div style=\"display: none; margin: 10px;\"></div>')).toHaveCss({display: \"none\", margin: \"10px\"})`\r\n  - e.g. `expect($('<div style=\"display: none; margin: 10px;\"></div>')).toHaveCss({margin: \"10px\"})`\r\n- `toBeSelected()`\r\n  - only for tags that have selected attribute\r\n  - e.g. `expect($('<option selected=\"selected\"></option>')).toBeSelected()`\r\n- `toBeVisible()`\r\n  - Elements are considered visible if they consume space in the document. Visible elements have a width or height that is greater than zero.\r\n- `toContain(jQuerySelector)`\r\n  - e.g. `expect($('<div><span class=\"some-class\"></span></div>')).toContain('span.some-class')`\r\n- `toBeMatchedBy(jQuerySelector)`\r\n  - Check to see if the set of matched elements matches the given selector\r\n  - e.g.  `expect($('<span></span>').addClass('js-something')).toBeMatchedBy('.js-something')`\r\n- `toExist()`\r\n- `toHaveAttr(attributeName, attributeValue)`\r\n  - attribute value is optional, if omitted it will check only if attribute exists\r\n- `toHaveProp(propertyName, propertyValue)`\r\n  - property value is optional, if omitted it will check only if property exists\r\n- `toHaveBeenTriggeredOn(selector)`\r\n  - if event has been triggered on `selector` (see \"Event Spies\", below)\r\n- `toHaveBeenTriggered()`\r\n  - if event has been triggered on `selector` (see \"Event Spies\", below)\r\n- `toHaveBeenTriggeredOnAndWith(selector, extraParameters)`\r\n  - if event has been triggered on `selector` and with `extraParameters`\r\n- `toHaveBeenPreventedOn(selector)`\r\n  - if event has been prevented on `selector` (see \"Event Spies\", below)\r\n- `toHaveBeenPrevented()`\r\n  - if event has been prevented on `selector` (see \"Event Spies\", below)\r\n- `toHaveClass(className)`\r\n  - e.g. `expect($('<div class=\"some-class\"></div>')).toHaveClass(\"some-class\")`  \r\n- `toHaveData(key, value)`\r\n  - value is optional, if omitted it will check only if an entry for that key exists\r\n- `toHaveHtml(string)`\r\n  - e.g. `expect($('<div><span></span></div>')).toHaveHtml('<span></span>')`\r\n- `toContainHtml(string)`\r\n  - e.g. `expect($('<div><ul></ul><h1>header</h1></div>')).toContainHtml('<ul></ul>')`\r\n- `toContainText(string)`\r\n  - e.g. `expect($('<div><ul></ul><h1>header</h1></div>')).toContainText('header')`\r\n- `toHaveId(id)`\r\n  - e.g. `expect($('<div id=\"some-id\"></div>')).toHaveId(\"some-id\")`\r\n- `toHaveText(string)`\r\n  - accepts a String or regular expression\r\n  - e.g. `expect($('<div>some text</div>')).toHaveText('some text')`\r\n- `toHaveValue(value)`\r\n  - only for tags that have value attribute\r\n  - e.g. `expect($('<input type=\"text\" value=\"some text\"/>')).toHaveValue('some text')`\r\n- `toHaveLength(value)`\r\n  - e.g. `expect($('ul > li')).toHaveLength(3)`\r\n- `toBeDisabled()`\r\n  - e.g. `expect('<input type='submit' disabled='disabled'/>').toBeDisabled()`\r\n- `toBeFocused()`\r\n  - e.g. `expect($('<input type='text' />').focus()).toBeFocused()`\r\n- `toHandle(eventName)`\r\n  - e.g. `expect($form).toHandle(\"submit\")`\r\n- `toHandleWith(eventName, eventHandler)`\r\n  - e.g. `expect($form).toHandleWith(\"submit\", yourSubmitCallback)`\r\n  \r\nThe same as with standard Jasmine matchers, all of above custom matchers may be inverted by using `.not` prefix, e.g.:\r\n\r\n    expect($('<div>some text</div>')).not.toHaveText(/other/)\r\n\r\n## HTML Fixtures\r\n\r\nThe Fixture module of jasmine-jquery allows you to load HTML content to be used by your tests. The overall workflow is like follows:\r\n\r\nIn _myfixture.html_ file:\r\n\r\n    <div id=\"my-fixture\">some complex content here</div>\r\n    \r\nInside your test:\r\n\r\n    loadFixtures('myfixture.html');\r\n    $('#my-fixture').myTestedPlugin();\r\n    expect($('#my-fixture')).to...;\r\n    \r\nBy default, fixtures are loaded from `spec/javascripts/fixtures`. You can configure this path: `jasmine.getFixtures().fixturesPath = 'my/new/path';`.\r\n\r\nYour fixture is being loaded into `<div id=\"jasmine-fixtures\"></div>` container that is automatically added to the DOM by the Fixture module (If you _REALLY_ must change id of this container, try: `jasmine.getFixtures().containerId = 'my-new-id';` in your test runner). To make tests fully independent, fixtures container is automatically cleaned-up between tests, so you don't have to worry about left-overs from fixtures loaded in preceeding test. Also, fixtures are internally cached by the Fixture module, so you can load the same fixture file in several tests without penalty to your test suite's speed.\r\n\r\nTo invoke fixture related methods, obtain Fixtures singleton through a factory and invoke a method on it:\r\n\r\n    jasmine.getFixtures().load(...);\r\n    \r\nThere are also global short cut functions available for the most used methods, so the above example can be rewritten to just:\r\n\r\n    loadFixtures(...);\r\n    \r\nSeveral methods for loading fixtures are provided:\r\n\r\n- `load(fixtureUrl[, fixtureUrl, ...])`\r\n  - Loads fixture(s) from one or more files and automatically appends them to the DOM (to the fixtures container).\r\n- `appendLoad(fixtureUrl[, fixtureUrl, ...])`\r\n  - Same as load, but adds the fixtures to the pre-existing fixture container.\r\n- `read(fixtureUrl[, fixtureUrl, ...])`\r\n  - Loads fixture(s) from one or more files but instead of appending them to the DOM returns them as a string (useful if you want to process fixture's content directly in your test).\r\n- `set(html)`\r\n  - Doesn't load fixture from file, but instead gets it directly as a parameter (html parameter may be a string or a jQuery element, so both `set('<div></div>')` and `set($('<div/>'))` will work). Automatically appends fixture to the DOM (to the fixtures container). It is useful if your fixture is too simple to keep it in an external file or is constructed procedurally, but you still want Fixture module to automatically handle DOM insertion and clean-up between tests for you.\r\n- `appendSet(html)`\r\n  - Same as set, but adds the fixtures to the pre-existing fixture container.\r\n- `preload(fixtureUrl[, fixtureUrl, ...])`\r\n  - Pre-loads fixture(s) from one or more files and stores them into cache, without returning them or appending them to the DOM. All subsequent calls to `load` or `read` methods will then get fixtures content from cache, without making any AJAX calls (unless cache is manually purged by using `clearCache` method). Pre-loading all fixtures before a test suite is run may be useful when working with libraries like jasmine-ajax that block or otherwise modify the inner workings of JS or jQuery AJAX calls.\r\n  \r\nAll of above methods have matching global short cuts:\r\n\r\n- `loadFixtures(fixtureUrl[, fixtureUrl, ...])`\r\n- `appendLoadFixtures(fixtureUrl[, fixtureUrl, ...])`\r\n- `readFixtures(fixtureUrl[, fixtureUrl, ...])`\r\n- `setFixtures(html)`\r\n- `appendSetFixtures(html)`\r\n\r\nAlso, a helper method for creating HTML elements for your tests is provided:\r\n\r\n- `sandbox([{attributeName: value[, attributeName: value, ...]}])`\r\n\r\nIt creates an empty DIV element with a default id=\"sandbox\". If a hash of attributes is provided, they will be set for this DIV tag. If a hash of attributes contains id attribute it will override the default value. Custom attributes can also be set. So e.g.:\r\n\r\n    sandbox();\r\n    \r\nWill return:\r\n\r\n    <div id=\"sandbox\"></div>    \r\n    \r\nAnd:\r\n\r\n    sandbox({\r\n      id: 'my-id',\r\n      class: 'my-class',\r\n      myattr: 'my-attr'\r\n    });\r\n    \r\nWill return:\r\n\r\n    <div id=\"my-id\" class=\"my-class\" myattr=\"my-attr\"></div>\r\n\r\nSandbox method is useful if you want to quickly create simple fixtures in your tests without polluting them with HTML strings:\r\n\r\n    setFixtures(sandbox({class: 'my-class'}));\r\n    $('#sandbox').myTestedClassRemoverPlugin();\r\n    expect($('#sandbox')).not.toHaveClass('my-class');\r\n\r\nThis method also has a global short cut available:\r\n\r\n- `sandbox([{attributeName: value[, attributeName: value, ...]}])`\r\n\r\nAdditionally, two clean up methods are provided:\r\n\r\n- `clearCache()`\r\n  - purges Fixture module internal cache (you should need it only in very special cases; typically, if you need to use it, it may indicate a smell in your test code)\r\n- `cleanUp()`\r\n  - cleans-up fixtures container (this is done automatically between tests by Fixtures module, so there is no need to ever invoke this manually, unless you're testing a really fancy special case and need to clean-up fixtures in the middle of your test)\r\n  \r\nThese two methods do not have global short cut functions.\r\n\r\n## Style Fixtures\r\n\r\nThe StyleFixtures module is pretty much like the Fixtures module, but it allows you to load CSS content on the page while testing. It may be useful if your tests expect that certain css rules are applied to elements that you are testing. The overall workflow is typically the same:\r\n\r\nIn _mycssfixture.css_ file:\r\n\r\n    .elem { position: absolute }\r\n    \r\nInside your test:\r\n\r\n    loadStyleFixtures('mycssfixture.css');\r\n    $('#my-fixture').myTestedPlugin();\r\n    expect($('#my-fixture .elem')).toHaveCss({left: \"300px\"});\r\n\r\nNotice that if you haven't applied the `position: absolute` rule to the `.elem` and try to test its left position in some browsers (e.g. GoogleChrome) you will allways get the value `auto` even if your plugin did everything correct and applied positioning. So that's why you might need to load style fixtures. In Firefox though you will get the correct value even without the `position: absolute`.\r\n        \r\nBy default, style fixtures are loaded from `spec/javascripts/fixtures`. You can configure this path: `jasmine.getStyleFixtures().fixturesPath = 'my/new/path';`.\r\n\r\nLike in Fixtures module, StyleFixtures are also automatically cleaned-up between tests and are internally cached, so you can load the same fixture file in several tests without penalty to your test suite's speed.\r\n\r\nTo invoke fixture related methods, obtain StyleFixtures singleton through a factory and invoke a method on it:\r\n\r\n    jasmine.getStyleFixtures().load(...);\r\n    \r\nThere are also global short cut functions available for the most used methods, so the above example can be rewritten to just:\r\n\r\n    loadStyleFixtures(...);\r\n    \r\nSeveral methods for loading fixtures are provided:\r\n\r\n- `load(fixtureUrl[, fixtureUrl, ...])`\r\n  - Loads fixture(s) from one or more files and automatically appends them to the DOM into the HEAD element. This method will remove all existing fixtures loaded previously, if any.\r\n- `appendLoad(fixtureUrl[, fixtureUrl, ...])`\r\n  - Same as load, but it won't remove fixtures you added earlier.\r\n- `set(css)`\r\n  - Doesn't load fixture from file, but instead gets it directly as a parameter (e.g. `set('body {background: red}')`). Automatically appends style to the DOM. It is useful if your css fixture is too simple to keep it in an external file. This method will remove all existing fixtures loaded previously, if any.\r\n- `appendSet(css)`\r\n  - Same as set, but it won't remove fixtures you added earlier.\r\n- `preload(fixtureUrl[, fixtureUrl, ...])`\r\n  - Pre-loads fixture(s) from one or more files and stores them into cache, without returning them or appending them to the DOM. All subsequent calls to `load` methods will then get fixtures content from cache, without making any AJAX calls (unless cache is manually purged by using `clearCache` method).\r\n    \r\nAll of above methods have matching global short cuts:\r\n\r\n- `loadStyleFixtures(fixtureUrl[, fixtureUrl, ...])`\r\n- `appendLoadStyleFixtures(fixtureUrl[, fixtureUrl, ...])`\r\n- `setStyleFixtures(css)`\r\n- `appendSetStyleFixtures(css)`    \r\n\r\nAdditionally, two clean up methods are provided:\r\n\r\n- `clearCache()`\r\n  - purges StyleFixture module internal cache (you should need it only in very special cases; typically, if you need to use it, it may indicate a smell in your test code)\r\n- `cleanUp()`\r\n  - cleans-up all existing style fixtures (this is done automatically between tests, so there is no need to ever invoke this manually, unless you're testing a really fancy special case and need to clean-up fixtures in the middle of your test)\r\n  \r\nThese two methods do not have global short cut functions.\r\n\r\n## JSON Fixtures\r\n\r\nThe JSONFixtures modules allows you to load JSON data from file (instead of putting huge blocks of data in the spec files).  \r\n\r\nIn _myjsonfixture.json_ file:\r\n\r\n    {\"property1\":\"value1\", \"array1\":[1,2,3]}\r\n    \r\nInside your test:\r\n\r\n    var data = getJSONFixture('myjsonfixture.json');\r\n    // or load and get the JSON two-step\r\n    var fixtures = loadJSONFixtures('myjsonfixture.json');\r\n    var data = fixtures['myjsonfixture.json'];\r\n    \r\n    expect(myDataManipulator.processData(test_data)).to...)\r\n    \r\nBy default, fixtures are loaded from `spec/javascripts/fixtures/json`. You can configure this path: `jasmine.getJSONFixtures().fixturesPath = 'my/new/path';`.\r\n\r\nYour fixture data is loaded into an object stashed by the JSONFixtures structure.  You fetch the data using the filename as the key.  This allows you to load multiple chunks of test data in a spec.  \r\n\r\nBecause a deep copy of Javascript objects can be a little tricky, this module will refetch data each time you call `load`.  If you modify the data within a spec, you must call `load` or `loadJSONFixtures` again to repopulate the data.\r\n\r\nTo invoke fixture related methods, obtain Fixtures singleton through a factory and invoke a method on it:\r\n\r\n    jasmine.getJSONFixtures().load(...);\r\n    \r\nThere are also global short cut functions available for the most used methods, so the above example can be rewritten to just:\r\n\r\n    loadJSONFixtures(...);\r\n    \r\nSeveral methods for loading fixtures are provided:\r\n\r\n- `load(fixtureUrl[, fixtureUrl, ...])`\r\n  - Loads fixture(s) from one or more files and automatically adds them to the fixture list.  This method returns the entire set of fixtures keyed by their filename.\r\n  \r\nAll of above methods have matching global short cuts:\r\n\r\n- `loadJSONFixtures(fixtureUrl[, fixtureUrl, ...])`\r\n\r\n- `getJSONFixture(fixtureUrl)`\r\n  - After you've loaded fixture files, this global helper will retrieve the fixture data given the fixtureUrl\r\n\r\n\r\n## Event Spies\r\n\r\nSpying on jQuery events can be done with `spyOnEvent` and\r\n`expect(eventName).toHaveBeenTriggeredOn(selector)` or\r\n`expect(spyEvent).toHaveBeenTriggered()` . First, spy on the event:\r\n\r\n    var spyEvent = spyOnEvent('#some_element', 'click');\r\n    $('#some_element').click();\r\n    expect('click').toHaveBeenTriggeredOn('#some_element');\r\n    expect(spyEvent).toHaveBeenTriggered();\r\n\r\nYou can reset spy events\r\n\r\n    var spyEvent = spyOnEvent('#some_element', 'click');\r\n    $('#some_element').click();\r\n    expect('click').toHaveBeenTriggeredOn('#some_element');\r\n    expect(spyEvent).toHaveBeenTriggered();\r\n    // reset spy events\r\n    spyEvent.reset();\r\n    expect('click').not.toHaveBeenTriggeredOn('#some_element');\r\n    expect(spyEvent).not.toHaveBeenTriggered();\r\n\r\nYou can similarly check if triggered event was prevented:\r\n\r\n    var spyEvent = spyOnEvent('#some_element', 'click');\r\n    $('#some_element').click(function(event){event.preventDefault();});\r\n    $('#some_element').click();\r\n    expect('click').toHaveBeenPreventedOn('#some_element');\r\n    expect(spyEvent).toHaveBeenPrevented();\r\n\r\nYou can also check if the triggered event was stopped:\r\n\r\n    var spyEvent = spyOnEvent('#some_element', 'click');\r\n    $('#some_element').click(function(event){event.stopPropagation();});\r\n    $('#some_element').click();\r\n    expect('click').toHaveBeenStoppedOn('#some_element');\r\n    expect(spyEvent).toHaveBeenStopped();\r\n\r\nMuch thanks to Luiz Fernando Ribeiro for his\r\n[article on Jasmine event spies](http://luizfar.wordpress.com/2011/01/10/testing-events-on-jquery-objects-with-jasmine/).\r\n\r\n## Dependencies\r\n\r\njasmine-jquery was tested with Jasmine 1.2 and jQuery 1.8 on IE, FF, Chrome, and Safari. There is a high chance it will work with older versions and other browsers as well, but I don't typically run test suite against them when adding new features.\r\n\r\n## Cross domain policy problems under Chrome\r\n\r\nNewer versions of Chrome don't allow file:// URIs read other file:// URIs. In effect, jasmine-jquery cannot properly load fixtures under some versions of Chrome. An override for this is to run Chrome with a switch `--allow-file-access-from-files`. The full discussion on this topic can be found in [this GitHub ticket](https://github.com/velesin/jasmine-jquery/issues/4).\r\n\r\nUnder Windows 7, you have to launch `C:\\Users\\[UserName]\\AppData\\Local\\Google\\Chrome[ SxS]\\Application\\chrome.exe --allow-file-access-from-files`\r\n\r\n## Mocking with jasmine-ajax\r\n\r\n[jasmine-ajax](https://github.com/pivotal/jasmine-ajax) library doesn't let user to manually start / stop XMLHttpRequest mocking, but instead it overrides XMLHttpRequest automatically when loaded. This breaks jasmine-jquery fixtures as fixture loading mechanism uses jQuery.ajax, that stops to function the very moment jasmine-ajax is loaded. A workaround for this may be to invoke jasmine-jquery `preloadFixtures` function (specifying all required fixtures) before jasmine-ajax is loaded. This way subsequent calls to `loadFixtures` or `readFixtures` methods will get fixtures content from cache, without need to use jQuery.ajax and thus will work correctly even after jasmine-ajax is loaded.\r\n\r\n## Testing with Javascript Test Driver\r\n\r\nWhen using [jstd](http://code.google.com/p/js-test-driver/) and the jasmine adapter you will need to include jasmine-jquery.js after your jasmine-jstd-adapter files, otherwise jasmine-jquery matchers will not be available when tests are executed. Check out [this issue](https://github.com/velesin/jasmine-jquery/issues/95#issuecomment-9293180) for a thorough configuration example too.\r\n\r\n## Contributing\r\n\r\njasmine-jquery is maintained by [Travis Jeffery](http://github.com/travisjeffery).\r\n\r\n### Setup\r\n\r\n- Fork the project and clone the repository.\r\n\r\n    [Here's how.](http://help.github.com/fork-a-repo/)\r\n- Create a dedicated branch.\r\n\r\n    `git checkout -b your_feature`\r\n\r\n### Writing the Code\r\n\r\n- Get the code right.\r\n- Include tests that fail without your code, and pass with it.\r\n- Update the (surrounding) documentation, examples elsewhere, and the guides: whatever is affected by your contribution.\r\n- Follow the conventions in the source you see used already, basically [npm coding style](http://npmjs.org/doc/coding-style.html)\r\n\r\nIf you can, have another developer sanity check your change.\r\n\r\n### Committing\r\n\r\n- Commit your change with a message on what you changed in the commit.\r\n\r\n    `git commit -am \"A commit message on what you changed\"`\r\n- Please squash your commits when appropriate. This simplifies future cherry picks, and also keeps the git log clean.\r\n\r\n    [Here's how.](http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html)\r\n- Push to your remote\r\n\r\n    `git push origin your_feature`\r\n\r\n### Issue a Pull Request\r\n\r\n- Navigate to the jasmine-jquery GitHub page, press \"Pull Request\".\r\n- Write your branch name in the branch field, press \"Update Commit Range\".\r\n- Fill in some details about your potential patch including a meaningful\r\n  title. When finished, press \"Send pull request\".\r\n\r\n(These guidelines are heavily inspired and similar to [Rails's](http://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-code)).\r\n",
  "readmeFilename": "README.md",
  "_id": "jasmine-jquery@1.5.8",
  "description": "jasmine-jquery provides two extensions for [Jasmine](http://pivotal.github.com/jasmine/) JavaScript Testing Framework:",
  "repository": {
    "type": "git",
    "url": "git://github.com/velesin/jasmine-jquery"
  }
}